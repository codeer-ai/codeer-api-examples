<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Codeer AI</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
          "Helvetica", "Arial", sans-serif;
        background: #343541;
        height: 100vh;
        overflow: hidden;
      }

      #app {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 1200px;
        margin: 0 auto;
        background: #343541;
      }

      .header {
        background: #202123;
        padding: 15px 20px;
        border-bottom: 1px solid #4d4d4f;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .header h1 {
        color: #ececf1;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .new-chat-btn {
        padding: 8px 16px;
        background: transparent;
        color: #ececf1;
        border: 1px solid #565869;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .new-chat-btn:hover {
        background: #40414f;
      }

      .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .messages-container::-webkit-scrollbar {
        width: 8px;
      }

      .messages-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .messages-container::-webkit-scrollbar-thumb {
        background: #565869;
        border-radius: 4px;
      }

      .message {
        display: flex;
        gap: 16px;
        padding: 20px;
        animation: fadeIn 0.3s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        background: #343541;
      }

      .message.assistant {
        background: #444654;
      }

      .avatar {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        flex-shrink: 0;
      }

      .message.user .avatar {
        background: #5436da;
      }

      .message.assistant .avatar {
        background: #19c37d;
      }

      .message-content {
        flex: 1;
        color: #ececf1;
        line-height: 1.6;
        font-size: 16px;
        word-wrap: break-word;
      }

      .typing-indicator {
        display: flex;
        gap: 4px;
        padding: 4px 0;
      }

      .typing-indicator span {
        width: 8px;
        height: 8px;
        background: #ececf1;
        border-radius: 50%;
        animation: typing 1.4s infinite;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%,
        60%,
        100% {
          opacity: 0.3;
        }
        30% {
          opacity: 1;
        }
      }

      .input-area {
        padding: 20px;
        background: #343541;
        border-top: 1px solid #4d4d4f;
      }

      .input-wrapper {
        max-width: 800px;
        margin: 0 auto;
        position: relative;
      }

      .input-container {
        display: flex;
        align-items: center;
        background: #40414f;
        border-radius: 12px;
        padding: 12px 16px;
        gap: 12px;
        border: 1px solid #565869;
        transition: border-color 0.2s;
      }

      .input-container:focus-within {
        border-color: #19c37d;
      }

      .upload-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
        gap: 10px;
      }

      .upload-btn {
        padding: 8px 12px;
        background: #40414f;
        border: 1px dashed #565869;
        border-radius: 8px;
        color: #ececf1;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .upload-btn:hover:not(:disabled) {
        background: #4d4d4f;
        border-color: #19c37d;
      }

      .upload-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        color: #8e8ea0;
        font-size: 14px;
      }

      .upload-error {
        color: #ff6b6b;
        font-size: 14px;
      }

      .attachment-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }

      .attachment-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 20px;
        background: #202123;
        border: 1px solid #565869;
        color: #ececf1;
        font-size: 13px;
      }

      .attachment-name {
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .attachment-remove {
        background: transparent;
        border: none;
        color: #8e8ea0;
        cursor: pointer;
        font-size: 14px;
        padding: 0 4px;
      }

      .attachment-remove:hover {
        color: #ff6b6b;
      }

      .message-attachments {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      .message-attachment {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid #565869;
        background: #2a2b32;
        color: #ececf1;
        font-size: 13px;
      }

      .message-attachment-icon {
        font-size: 14px;
      }

      .message-attachment-name {
        max-width: 220px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      textarea {
        flex: 1;
        background: transparent;
        border: none;
        color: #ececf1;
        font-size: 16px;
        font-family: inherit;
        resize: none;
        outline: none;
        max-height: 200px;
        line-height: 1.5;
      }

      textarea::placeholder {
        color: #8e8ea0;
      }

      .send-btn {
        width: 32px;
        height: 32px;
        background: #19c37d;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .send-btn:hover:not(:disabled) {
        background: #1a9f6a;
      }

      .send-btn:disabled {
        background: #40414f;
        cursor: not-allowed;
        opacity: 0.5;
      }

      .send-btn svg {
        width: 16px;
        height: 16px;
        fill: white;
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #8e8ea0;
        gap: 20px;
      }

      .empty-state-icon {
        font-size: 64px;
      }

      .empty-state h2 {
        font-size: 24px;
        color: #ececf1;
      }

      .example-prompts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 12px;
        max-width: 800px;
        margin-top: 20px;
      }

      .example-prompt {
        background: #40414f;
        padding: 16px;
        border-radius: 8px;
        border: 1px solid #565869;
        cursor: pointer;
        transition: all 0.2s;
        color: #ececf1;
        font-size: 14px;
      }

      .example-prompt:hover {
        background: #4d4d4f;
        border-color: #19c37d;
      }

      .streaming-cursor {
        display: inline-block;
        width: 2px;
        height: 1em;
        background: #19c37d;
        margin-left: 2px;
        animation: blink 1s infinite;
        vertical-align: text-bottom;
      }

      @keyframes blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="header">
        <h1>
          <span>ðŸ’¬</span>
          <span>Codeer AI</span>
        </h1>
        <button class="new-chat-btn" @click="clearChat">+ New Chat</button>
      </div>

      <div class="messages-container" ref="messagesContainer">
        <div v-if="messages.length === 0" class="empty-state">
          <div class="empty-state-icon">ðŸ¤–</div>
          <h2>How can I help you today?</h2>
          <div class="example-prompts">
            <div
              class="example-prompt"
              @click="sendExamplePrompt('Tell me a fun fact about space')"
            >
              Tell me a fun fact about space
            </div>
            <div
              class="example-prompt"
              @click="sendExamplePrompt('Explain quantum computing')"
            >
              Explain quantum computing
            </div>
            <div
              class="example-prompt"
              @click="sendExamplePrompt('Give me a recipe for chocolate cake')"
            >
              Give me a recipe for chocolate cake
            </div>
          </div>
        </div>

        <div
          v-for="message in messages"
          :key="message.id"
          class="message"
          :class="message.role"
        >
          <div class="avatar">{{ message.role === 'user' ? 'ðŸ‘¤' : 'ðŸ¤–' }}</div>
          <div class="message-content">
            <div
              v-if="message.role === 'assistant' && message.content === '' && isTyping"
              class="typing-indicator"
            >
              <span></span>
              <span></span>
              <span></span>
            </div>
            <div v-else style="white-space: pre-wrap">
              {{ message.content }}
              <span
                v-if="message.id === currentAssistantMessageId && message.content !== ''"
                class="streaming-cursor"
              ></span>
            </div>
            <div
              v-if="message.attachments && message.attachments.length > 0"
              class="message-attachments"
            >
              <div
                v-for="file in message.attachments"
                :key="file.uuid"
                class="message-attachment"
              >
                <span class="message-attachment-icon">ðŸ“Ž</span>
                <span class="message-attachment-name" :title="file.name">{{
                  file.name
                }}</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="input-area">
        <div class="input-wrapper">
          <input
            type="file"
            ref="fileInput"
            style="display: none"
            @change="handleFileChange"
          />
          <div class="upload-row">
            <button
              class="upload-btn"
              @click="handleUploadClick"
              :disabled="isUploading"
            >
              <span>ðŸ“Ž</span>
              <span>{{ isUploading ? "Uploading..." : "Attach file" }}</span>
            </button>
            <div class="upload-status">
              <span v-if="isUploading">Uploading to server...</span>
              <span v-else-if="attachments.length > 0">
                {{ attachments.length }} file{{ attachments.length > 1 ? "s" : "" }}
                attached
              </span>
              <span v-else>Optional: upload files to share with the chat</span>
            </div>
          </div>
          <div v-if="uploadError" class="upload-error">{{ uploadError }}</div>
          <div v-if="attachments.length > 0" class="attachment-list">
            <div v-for="file in attachments" :key="file.uuid" class="attachment-pill">
              <span class="attachment-name" :title="file.name">{{ file.name }}</span>
              <span class="upload-status">attached</span>
              <button
                class="attachment-remove"
                @click="removeAttachment(file.uuid)"
                title="Remove attachment"
              >
                âœ•
              </button>
            </div>
          </div>
          <div class="input-container">
            <textarea
              v-model="userInput"
              @keydown.enter.exact.prevent="sendMessage"
              placeholder="Send a message..."
              rows="1"
              ref="textarea"
            ></textarea>
            <button
              class="send-btn"
              @click="sendMessage"
              :disabled="!userInput.trim() || isTyping || isUploading"
            >
              <svg viewBox="0 0 24 24">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const { createApp } = Vue;

      /*
       * Codeer Chat API Example
       *
       * This example demonstrates:
       * 1. Creating a chat session with createChat()
       * 2. Sending messages with streaming responses via sendQuestion()
       * 3. Handling Server-Sent Events (SSE) for real-time streaming
       *
       * Usage:
       * - Set CODEER_API_KEY, CODEER_API_ROOT, and CODEER_DEFAULT_AGENT
       * - Chat session is created automatically on first message
       * - Messages stream in real-time via SSE
       */

      // ============================================
      // API Configuration
      // ============================================
      const CODEER_API_KEY = "your_workspace_api_key";
      const CODEER_API_ROOT = "http://localhost:8000";
      const CODEER_DEFAULT_AGENT = undefined; // Optional: Set agent UUID or leave undefined for default agent

      // ============================================
      // API Functions
      // ============================================

      /**
       * Create a new chat session
       * Returns chat object with ID for subsequent messages
       */
      async function createChat(name) {
        name = name || "Untitled";
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats`;

          const body = {
            name: name,
          };

          if (CODEER_DEFAULT_AGENT) {
            body.agent_id = CODEER_DEFAULT_AGENT;
          }

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": CODEER_API_KEY,
            },
            body: JSON.stringify(body),
          });

          const resp = await response.json().catch(() => null);
          if (!response.ok || !resp || resp.error_code !== 0) {
            const message =
              (resp && (resp.message || resp.error)) ||
              `Failed to create chat (HTTP ${response.status})`;
            throw new Error(`API error: ${message}`);
          }

          console.log("âœ… New chat created:", resp);
          return resp.data;
        } catch (err) {
          console.error("âŒ Error creating chat:", err);
          throw err;
        }
      }

      /**
       * Send a message and receive streaming response via Server-Sent Events (SSE)
       * @param {string} historyId - Chat session ID from createChat()
       * @param {Object} payload - { message: string, stream: boolean, agent_id?: number }
       * @param {Function} onMessage - Called for each chunk of the response
       * @param {Function} onDone - Called when streaming completes
       * @param {Function} onError - Called if an error occurs
       */
      async function sendQuestion(
        historyId,
        payload,
        onMessage,
        onDone,
        onError
      ) {
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats/${historyId}/messages`;

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": CODEER_API_KEY,
            },
            body: JSON.stringify(payload),
          });

          let errorData = null;
          if (!response.ok) {
            errorData = await response.json().catch(() => null);
            const message =
              (errorData && (errorData.message || errorData.error)) ||
              `HTTP ${response.status}`;
            throw new Error(`API error: ${message}`);
          }

          if (response.body === null) {
            throw new Error("No response body");
          }

          // Parse SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          let eventName = null;
          let dataLines = [];
          let doneCalled = false;
          let hasOutputText = false;

          const dispatchEvent = async () => {
            if (dataLines.length === 0 && !eventName) return false;

            const rawPayload = dataLines.join("\n").trim();
            const ev = (eventName || "").toLowerCase();

            if (!rawPayload) {
              eventName = null;
              dataLines = [];
              return false;
            }

            if (rawPayload === "[DONE]") {
              if (onDone && !doneCalled) {
                onDone();
                doneCalled = true;
              }
              return true;
            }

            let parsed = null;
            if (rawPayload.startsWith("{")) {
              try {
                parsed = JSON.parse(rawPayload);
              } catch (e) {
                console.error("Failed to parse SSE JSON:", e, rawPayload);
              }
            }

            if (ev === "error" || (parsed && parsed.type === "error")) {
              const message =
                (parsed && (parsed.message || parsed.error)) ||
                rawPayload ||
                "Stream error";
              if (onError) onError(new Error(message));
              if (onDone && !doneCalled) {
                onDone();
                doneCalled = true;
              }
              return true;
            }

            if (onMessage) {
              let textChunk = null;

              if (
                parsed &&
                parsed.type === "response.output_text.delta" &&
                typeof parsed.delta === "string"
              ) {
                textChunk = parsed.delta;
                hasOutputText = true;
              } else if (
                parsed &&
                parsed.type === "response.output_text.completed" &&
                typeof parsed.final_text === "string" &&
                !hasOutputText
              ) {
                // Fallback if no deltas were streamed
                textChunk = parsed.final_text;
              } else if (!parsed) {
                // Legacy plain-text streaming fallback
                textChunk = rawPayload;
              }

              if (textChunk && textChunk.length > 0) {
                try {
                  onMessage(textChunk);
                } catch (e) {
                  console.error("Error processing message:", e);
                }
              }
            }

            eventName = null;
            dataLines = [];
            return false;
          };

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            let pos = 0;
            while (true) {
              const nl = buffer.indexOf("\n", pos);
              if (nl === -1) {
                buffer = buffer.slice(pos);
                break;
              }

              let line = buffer.slice(pos, nl);
              pos = nl + 1;
              if (line.endsWith("\r")) line = line.slice(0, -1);

              if (line === "") {
                if (dataLines.length > 0 || eventName) {
                  const shouldStop = await dispatchEvent();
                  if (shouldStop) {
                    try {
                      await reader.cancel();
                    } catch {}
                    return;
                  }
                }
                continue;
              }

              if (line.startsWith(":")) continue;

              if (line.startsWith("event:")) {
                eventName = line.slice(6).trim();
                continue;
              }

              if (line.startsWith("data:")) {
                const dataContent = line.slice(5).replace(/^\s/, "");

                if (dataContent.trim() === "[DONE]") {
                  if (onDone && !doneCalled) {
                    onDone();
                    doneCalled = true;
                  }
                  try {
                    await reader.cancel();
                  } catch {}
                  return;
                }

                dataLines.push(dataContent);
                continue;
              }

              if (dataLines.length > 0) {
                dataLines.push(line);
              }
            }
          }

          if (dataLines.length > 0 || eventName) {
            await dispatchEvent();
          }
          if (onDone && !doneCalled) onDone();
        } catch (err) {
          console.error("SSE Error:", err);
          if (onError) {
            onError(err instanceof Error ? err : new Error("Unknown error"));
          }
          throw err;
        }
      }

      /**
       * Upload a file to get an attachment UUID for messages
       */
      async function uploadFile(file) {
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats/upload-file`;
          const formData = new FormData();
          formData.append("file", file);
          formData.append("data", JSON.stringify({ scope: "persistent" }));

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "x-api-key": CODEER_API_KEY,
            },
            body: formData,
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(
              `Upload failed: ${errorData.message || response.statusText} (${
                response.status
              })`
            );
          }

          const resp = await response.json();
          if (resp.error_code !== 0) {
            throw new Error(
              resp.data?.error_msg || resp.message || "Upload failed"
            );
          }

          console.log("ðŸ“Ž File uploaded:", resp.data);
          return resp.data;
        } catch (err) {
          console.error("âŒ Error uploading file:", err);
          throw err;
        }
      }

      // ============================================
      // Vue Application - UI Logic
      // ============================================
      createApp({
        data() {
          return {
            userInput: "",
            messages: [],
            isTyping: false,
            nextId: 1,
            currentAssistantMessageId: null,
            historyId: null, // Chat session ID
            agentId: CODEER_DEFAULT_AGENT, // Agent ID from configuration
            isCreatingChat: false,
            attachments: [],
            isUploading: false,
            uploadError: "",
          };
        },
        methods: {
          handleUploadClick() {
            const input = this.$refs.fileInput;
            if (input) input.click();
          },

          async handleFileChange(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            this.uploadError = "";
            this.isUploading = true;
            try {
              const uploaded = await uploadFile(file);
              if (!this.attachments.some((att) => att.uuid === uploaded.uuid)) {
                this.attachments.push({
                  uuid: uploaded.uuid,
                  name: uploaded.original_name || file.name,
                  size: uploaded.size || file.size,
                });
              }
            } catch (error) {
              this.uploadError = error.message || "Failed to upload file";
            } finally {
              this.isUploading = false;
              event.target.value = "";
            }
          },

          removeAttachment(uuid) {
            this.attachments = this.attachments.filter(
              (item) => item.uuid !== uuid
            );
          },

          async sendMessage() {
            const input = this.userInput.trim();
            if (!input || this.isTyping || this.isUploading) return;

            const attachmentsForSend = this.attachments.map((file) => ({
              ...file,
            }));

            this.messages.push({
              id: this.nextId++,
              role: "user",
              content: input,
              attachments: attachmentsForSend,
            });

            this.userInput = "";
            this.scrollToBottom();
            this.isTyping = true;

            if (!this.historyId) {
              try {
                await this.createNewChat(input);
              } catch (error) {
                console.error("Failed to create chat:", error);
                this.messages.push({
                  id: this.nextId++,
                  role: "assistant",
                  content: `âŒ Error: Failed to create chat session\n\nPlease check:\n- API key is valid\n- Backend server is running\n- CORS is properly configured`,
                });
                this.isTyping = false;
                this.scrollToBottom();
                return;
              }
            }

            this.attachments = [];
            this.uploadError = "";

            await this.sendMessageWithAPI(input, attachmentsForSend);
          },

          async sendMessageWithAPI(message, attachmentsForSend = []) {
            const assistantMessageId = this.nextId++;
            this.currentAssistantMessageId = assistantMessageId;

            this.messages.push({
              id: assistantMessageId,
              role: "assistant",
              content: "",
            });

            try {
              const attachmentIds = attachmentsForSend.map((file) => file.uuid);
              const payload = {
                message: message,
                stream: true,
                agent_id: this.agentId,
              };

              if (attachmentIds.length > 0) {
                payload.attached_file_uuids = attachmentIds;
              }

              let isFirstChunk = true;
              await sendQuestion(
                this.historyId,
                payload,
                (data) => {
                  const messageIndex = this.messages.findIndex(
                    (msg) => msg.id === assistantMessageId
                  );
                  if (messageIndex !== -1) {
                    if (isFirstChunk) {
                      this.isTyping = false;
                      isFirstChunk = false;
                    }
                    this.messages[messageIndex].content += data;
                    this.scrollToBottom();
                  }
                },
                () => {
                  this.isTyping = false;
                  this.currentAssistantMessageId = null;
                  this.scrollToBottom();
                },
                (error) => {
                  console.error("âŒ API Error:", error);
                  const messageIndex = this.messages.findIndex(
                    (msg) => msg.id === assistantMessageId
                  );
                  if (messageIndex !== -1) {
                    this.messages[
                      messageIndex
                    ].content = `âŒ Error: ${error.message}\n\nPlease check:\n- API key is valid\n- Backend server is running\n- CORS is properly configured`;
                  }
                  this.isTyping = false;
                  this.currentAssistantMessageId = null;
                  this.scrollToBottom();
                }
              );
            } catch (error) {
              console.error("Streaming error:", error);
            }
          },

          sendExamplePrompt(prompt) {
            this.userInput = prompt;
            this.sendMessage();
          },

          scrollToBottom() {
            this.$nextTick(() => {
              const container = this.$refs.messagesContainer;
              if (container) {
                container.scrollTop = container.scrollHeight;
              }
            });
          },

          async createNewChat(name) {
            if (this.isCreatingChat) return;

            this.isCreatingChat = true;
            try {
              const newHistory = await createChat(name.substring(0, 256));
              this.historyId = newHistory.id;
              console.log(`ðŸ†• Chat created with ID: ${newHistory.id}`);
            } finally {
              this.isCreatingChat = false;
            }
          },

          async clearChat() {
            this.historyId = null;
            this.messages = [];
            this.userInput = "";
            this.isTyping = false;
            this.currentAssistantMessageId = null;
            this.attachments = [];
            this.uploadError = "";
          },
        },
        mounted() {
          this.$watch("userInput", () => {
            const textarea = this.$refs.textarea;
            if (textarea) {
              textarea.style.height = "auto";
              textarea.style.height = textarea.scrollHeight + "px";
            }
          });

          console.log("ðŸš€ Codeer Chat initialized");
        },
      }).mount("#app");
    </script>
  </body>
</html>
