<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Codeer AI</title>
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
          "Helvetica", "Arial", sans-serif;
        background: #343541;
        height: 100vh;
        overflow: hidden;
      }

      #app {
        width: 100%;
        height: 100vh;
      }

      .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 1200px;
        width: 100%;
        margin: 0 auto;
        background: #343541;
      }

      .header {
        background: #202123;
        padding: 15px 20px;
        border-bottom: 1px solid #4d4d4f;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .header h1 {
        color: #ececf1;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .new-chat-btn {
        padding: 8px 16px;
        background: transparent;
        color: #ececf1;
        border: 1px solid #565869;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .new-chat-btn:hover {
        background: #40414f;
      }

      .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .messages-container::-webkit-scrollbar {
        width: 8px;
      }

      .messages-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .messages-container::-webkit-scrollbar-thumb {
        background: #565869;
        border-radius: 4px;
      }

      .message {
        display: flex;
        gap: 16px;
        padding: 20px;
        animation: fadeIn 0.3s ease-in;
        max-width: 100%;
        box-sizing: border-box;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        background: #343541;
      }

      .message.assistant {
        background: #444654;
      }

      .avatar {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        flex-shrink: 0;
      }

      .message.user .avatar {
        background: #5436da;
      }

      .message.assistant .avatar {
        background: #19c37d;
      }

      .message-content {
        flex: 1;
        color: #ececf1;
        line-height: 1.6;
        font-size: 16px;
        word-wrap: break-word;
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
      }

      .typing-indicator {
        display: flex;
        gap: 4px;
        padding: 4px 0;
      }

      .typing-indicator span {
        width: 8px;
        height: 8px;
        background: #ececf1;
        border-radius: 50%;
        animation: typing 1.4s infinite;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%,
        60%,
        100% {
          opacity: 0.3;
        }
        30% {
          opacity: 1;
        }
      }

      .input-area {
        padding: 20px;
        background: #343541;
        border-top: 1px solid #4d4d4f;
      }

      .input-wrapper {
        max-width: 800px;
        margin: 0 auto;
        position: relative;
      }

      .input-container {
        display: flex;
        align-items: center;
        background: #40414f;
        border-radius: 12px;
        padding: 12px 16px;
        gap: 12px;
        border: 1px solid #565869;
        transition: border-color 0.2s;
      }

      .input-container:focus-within {
        border-color: #19c37d;
      }

      .upload-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
        gap: 10px;
      }

      .upload-btn {
        padding: 8px 12px;
        background: #40414f;
        border: 1px dashed #565869;
        border-radius: 8px;
        color: #ececf1;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .upload-btn:hover:not(:disabled) {
        background: #4d4d4f;
        border-color: #19c37d;
      }

      .upload-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .upload-status {
        color: #8e8ea0;
        font-size: 14px;
      }

      .upload-error {
        color: #ff6b6b;
        font-size: 14px;
      }

      .attachment-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }

      .attachment-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 20px;
        background: #202123;
        border: 1px solid #565869;
        color: #ececf1;
        font-size: 13px;
      }

      .attachment-name {
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .attachment-remove {
        background: transparent;
        border: none;
        color: #8e8ea0;
        cursor: pointer;
        font-size: 14px;
        padding: 0 4px;
      }

      .attachment-remove:hover {
        color: #ff6b6b;
      }

      .message-attachments {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      .message-attachment {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid #565869;
        background: #2a2b32;
        color: #ececf1;
        font-size: 13px;
      }

      .message-attachment-icon {
        font-size: 14px;
      }

      .message-attachment-name {
        max-width: 220px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .reasoning-steps {
        margin-top: 8px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #202123;
        border: 1px solid #565869;
        color: #8e8ea0;
        font-size: 13px;
        max-width: 100%;
        box-sizing: border-box;
        overflow-x: hidden;
      }

      .reasoning-step {
        display: flex;
        align-items: flex-start;
        gap: 6px;
        margin-bottom: 4px;
      }

      .reasoning-step:last-child {
        margin-bottom: 0;
      }

      .reasoning-step-status {
        font-size: 14px;
      }

      .reasoning-step-content {
        flex: 1;
        min-width: 0;
      }

      .reasoning-step-json {
        margin-top: 4px;
        padding: 6px 8px;
        border-radius: 6px;
        background: #16171c;
        border: 1px solid #3a3b46;
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 12px;
        color: #d0d0d5;
        max-height: 160px;
        max-width: 100%;
        box-sizing: border-box;
        overflow-x: auto;
        overflow-y: auto;
        white-space: pre;
      }

      textarea {
        flex: 1;
        background: transparent;
        border: none;
        color: #ececf1;
        font-size: 16px;
        font-family: inherit;
        resize: none;
        outline: none;
        max-height: 200px;
        line-height: 1.5;
      }

      textarea::placeholder {
        color: #8e8ea0;
      }

      .send-btn {
        width: 32px;
        height: 32px;
        background: #19c37d;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .send-btn:hover:not(:disabled) {
        background: #1a9f6a;
      }

      .send-btn:disabled {
        background: #40414f;
        cursor: not-allowed;
        opacity: 0.5;
      }

      .send-btn svg {
        width: 16px;
        height: 16px;
        fill: white;
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #8e8ea0;
        gap: 20px;
      }

      .empty-state-icon {
        font-size: 64px;
      }

      .empty-state h2 {
        font-size: 24px;
        color: #ececf1;
      }

      .example-prompts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 12px;
        max-width: 800px;
        margin-top: 20px;
      }

      .example-prompt {
        background: #40414f;
        padding: 16px;
        border-radius: 8px;
        border: 1px solid #565869;
        cursor: pointer;
        transition: all 0.2s;
        color: #ececf1;
        font-size: 14px;
      }

      .example-prompt:hover {
        background: #4d4d4f;
        border-color: #19c37d;
      }

      .streaming-cursor {
        display: inline-block;
        width: 2px;
        height: 1em;
        background: #19c37d;
        margin-left: 2px;
        animation: blink 1s infinite;
        vertical-align: text-bottom;
      }

      @keyframes blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="text/babel">
      const { useState, useRef, useEffect } = React;

      /*
       * Codeer Chat API Example
       *
       * This example demonstrates:
       * 1. Creating a chat session with createChat()
       * 2. Sending messages with streaming responses via sendQuestion()
       * 3. Handling Server-Sent Events (SSE) for real-time streaming
       *
       * Usage:
       * - Set CODEER_API_KEY, CODEER_API_ROOT, and CODEER_DEFAULT_AGENT
       * - Chat session is created automatically on first message
       * - Messages stream in real-time via SSE
       */

      // ============================================
      // API Configuration
      // ============================================
      const CODEER_API_KEY = "your_workspace_api_key";
      const CODEER_API_ROOT = "http://localhost:8000";
      const CODEER_DEFAULT_AGENT = undefined; // Optional: Set agent UUID or leave undefined for default agent

      // ============================================
      // API Functions
      // ============================================

      /**
       * Create a new chat session
       * Returns chat object with ID for subsequent messages
       */
      async function createChat(name) {
        name = name || "Untitled";
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats`;

          const body = {
            name: name,
          };

          if (CODEER_DEFAULT_AGENT) {
            body.agent_id = CODEER_DEFAULT_AGENT;
          }

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": CODEER_API_KEY,
            },
            body: JSON.stringify(body),
          });

          const resp = await response.json().catch(() => null);
          if (!response.ok || !resp || resp.error_code !== 0) {
            const message =
              (resp && (resp.message || resp.error)) ||
              `Failed to create chat (HTTP ${response.status})`;
            throw new Error(`API error: ${message}`);
          }

          console.log("âœ… New chat created:", resp);
          return resp.data;
        } catch (err) {
          console.error("âŒ Error creating chat:", err);
          throw err;
        }
      }

      /**
       * Send a message and receive streaming response via Server-Sent Events (SSE)
       * @param {string} historyId - Chat session ID from createChat()
       * @param {Object} payload - { message: string, stream: boolean, agent_id?: number }
       * @param {Function} onMessage - Called for each output text chunk
       * @param {Function} onDone - Called when streaming completes
       * @param {Function} onError - Called if an error occurs
       * @param {Function} onReasoningEvent - Called for reasoning_step start/end events
       */
      async function sendQuestion(
        historyId,
        payload,
        onMessage,
        onDone,
        onError,
        onReasoningEvent
      ) {
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats/${historyId}/messages`;

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": CODEER_API_KEY,
            },
            body: JSON.stringify(payload),
          });

          let errorData = null;
          if (!response.ok) {
            errorData = await response.json().catch(() => null);
            const message =
              (errorData && (errorData.message || errorData.error)) ||
              `HTTP ${response.status}`;
            throw new Error(`API error: ${message}`);
          }

          if (response.body === null) {
            throw new Error("No response body");
          }

          // Parse SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          let eventName = null;
          let dataLines = [];
          let doneCalled = false;
          let hasOutputText = false;

          const dispatchEvent = async () => {
            if (dataLines.length === 0 && !eventName) return false;

            const rawPayload = dataLines.join("\n").trim();
            const ev = (eventName || "").toLowerCase();

            if (!rawPayload) {
              eventName = null;
              dataLines = [];
              return false;
            }

            if (rawPayload === "[DONE]") {
              if (onDone && !doneCalled) {
                onDone();
                doneCalled = true;
              }
              return true;
            }

            let parsed = null;
            if (rawPayload.startsWith("{")) {
              try {
                parsed = JSON.parse(rawPayload);
              } catch (e) {
                console.error("Failed to parse SSE JSON:", e, rawPayload);
              }
            }

            if (
              parsed &&
              (parsed.type === "response.reasoning_step.start" ||
                parsed.type === "response.reasoning_step.end")
            ) {
              if (typeof onReasoningEvent === "function") {
                try {
                  onReasoningEvent(parsed);
                } catch (e) {
                  console.error("Error processing reasoning event:", e);
                }
              }
              eventName = null;
              dataLines = [];
              return false;
            }

            if (ev === "error" || (parsed && parsed.type === "error")) {
              const message =
                (parsed && (parsed.message || parsed.error)) ||
                rawPayload ||
                "Stream error";
              if (onError) onError(new Error(message));
              if (onDone && !doneCalled) {
                onDone();
                doneCalled = true;
              }
              return true;
            }

            if (onMessage) {
              let textChunk = null;

              if (
                parsed &&
                parsed.type === "response.output_text.delta" &&
                typeof parsed.delta === "string"
              ) {
                textChunk = parsed.delta;
                hasOutputText = true;
              } else if (
                parsed &&
                parsed.type === "response.output_text.completed" &&
                typeof parsed.final_text === "string" &&
                !hasOutputText
              ) {
                // Fallback if no deltas were streamed
                textChunk = parsed.final_text;
              } else if (!parsed) {
                // Legacy plain-text streaming fallback
                textChunk = rawPayload;
              }

              if (textChunk && textChunk.length > 0) {
                try {
                  onMessage(textChunk);
                } catch (e) {
                  console.error("Error processing message:", e);
                }
              }
            }

            eventName = null;
            dataLines = [];
            return false;
          };

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            let pos = 0;
            while (true) {
              const nl = buffer.indexOf("\n", pos);
              if (nl === -1) {
                buffer = buffer.slice(pos);
                break;
              }

              let line = buffer.slice(pos, nl);
              pos = nl + 1;
              if (line.endsWith("\r")) line = line.slice(0, -1);

              if (line === "") {
                if (dataLines.length > 0 || eventName) {
                  const shouldStop = await dispatchEvent();
                  if (shouldStop) {
                    try {
                      await reader.cancel();
                    } catch {}
                    return;
                  }
                }
                continue;
              }

              if (line.startsWith(":")) continue;

              if (line.startsWith("event:")) {
                eventName = line.slice(6).trim();
                continue;
              }

              if (line.startsWith("data:")) {
                const dataContent = line.slice(5).replace(/^\s/, "");

                if (dataContent.trim() === "[DONE]") {
                  if (onDone && !doneCalled) {
                    onDone();
                    doneCalled = true;
                  }
                  try {
                    await reader.cancel();
                  } catch {}
                  return;
                }

                dataLines.push(dataContent);
                continue;
              }

              if (dataLines.length > 0) {
                dataLines.push(line);
              }
            }
          }

          if (dataLines.length > 0 || eventName) {
            await dispatchEvent();
          }
          if (onDone && !doneCalled) onDone();
        } catch (err) {
          console.error("SSE Error:", err);
          if (onError) {
            onError(err instanceof Error ? err : new Error("Unknown error"));
          }
          throw err;
        }
      }

      /**
       * Upload a file to get an attachment UUID for messages
       */
      async function uploadFile(file) {
        try {
          const apiUrl = `${CODEER_API_ROOT}/api/v1/chats/upload-file`;
          const formData = new FormData();
          formData.append("file", file);
          formData.append("data", JSON.stringify({ scope: "persistent" }));

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "x-api-key": CODEER_API_KEY,
            },
            body: formData,
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(
              `Upload failed: ${errorData.message || response.statusText} (${
                response.status
              })`
            );
          }

          const resp = await response.json();
          if (resp.error_code !== 0) {
            throw new Error(
              resp.data?.error_msg || resp.message || "Upload failed"
            );
          }

          console.log("ðŸ“Ž File uploaded:", resp.data);
          return resp.data;
        } catch (err) {
          console.error("âŒ Error uploading file:", err);
          throw err;
        }
      }

      // ============================================
      // React Application - UI Logic
      // ============================================
      function ChatApp() {
        const [userInput, setUserInput] = useState("");
        const [messages, setMessages] = useState([]);
        const [isTyping, setIsTyping] = useState(false);
        const [nextId, setNextId] = useState(1);
        const [currentAssistantMessageId, setCurrentAssistantMessageId] =
          useState(null);
        const [isCreatingChat, setIsCreatingChat] = useState(false);
        const [attachments, setAttachments] = useState([]);
        const [isUploading, setIsUploading] = useState(false);
        const [uploadError, setUploadError] = useState("");
        const [reasoningStepsByMessage, setReasoningStepsByMessage] =
          useState({});

        const messagesContainerRef = useRef(null);
        const textareaRef = useRef(null);
        const fileInputRef = useRef(null);
        const historyIdRef = useRef(null);
        const agentId = useRef(CODEER_DEFAULT_AGENT);

        const renderAssistantContent = (message) => {
          const stepsForMessage = reasoningStepsByMessage[message.id] || [];
          const text = message.content || "";

          const cursor =
            message.id === currentAssistantMessageId && text !== "" ? (
              <span className="streaming-cursor"></span>
            ) : null;

          if (stepsForMessage.length === 0) {
            return (
              <>
                {text}
                {cursor}
              </>
            );
          }

          const parts = [];
          const toolTagRegex = /<tool\s+id=([^>]+)>([\s\S]*?)<\/tool>/g;
          let lastIndex = 0;
          let match;

          while ((match = toolTagRegex.exec(text)) !== null) {
            const fullMatch = match[0];
            const matchStart = match.index;
            const matchEnd = matchStart + fullMatch.length;
            const idRaw = match[1];
            const inner = match[2];

            if (matchStart > lastIndex) {
              parts.push(text.slice(lastIndex, matchStart));
            }

            const toolId = idRaw.replace(/^["']|["']$/g, "");
            const matchedStep =
              stepsForMessage.find((step) => step.id === toolId) ||
              stepsForMessage.find(
                (step) => step.type === inner || step.content === inner
              );

            if (!matchedStep) {
              // If we cannot match, keep the raw tag text
              parts.push(text.slice(matchStart, matchEnd));
            } else {
              parts.push(
                <div
                  key={`tool-${message.id}-${toolId}-${matchStart}`}
                  className="reasoning-steps"
                >
                  <div className="reasoning-step">
                    <span className="reasoning-step-status">
                      {matchedStep.status === "completed" ? "âœ…" : "ðŸ§ "}
                    </span>
                    <span className="reasoning-step-content">
                      {matchedStep.type
                        ? `[${matchedStep.type}] (${matchedStep.id}) ${
                            matchedStep.content || ""
                          }`
                        : matchedStep.content || matchedStep.id}
                      {matchedStep.args && (
                        <div className="reasoning-step-json">
                          {JSON.stringify(matchedStep.args, null, 2)}
                        </div>
                      )}
                      {matchedStep.result && (
                        <div className="reasoning-step-json">
                          {JSON.stringify(matchedStep.result, null, 2)}
                        </div>
                      )}
                    </span>
                  </div>
                </div>
              );
            }

            lastIndex = matchEnd;
          }

          if (lastIndex < text.length) {
            parts.push(text.slice(lastIndex));
          }

          parts.push(cursor);

          return parts;
        };

        const scrollToBottom = () => {
          if (messagesContainerRef.current) {
            messagesContainerRef.current.scrollTop =
              messagesContainerRef.current.scrollHeight;
          }
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages]);

        useEffect(() => {
          if (textareaRef.current) {
            textareaRef.current.style.height = "auto";
            textareaRef.current.style.height =
              textareaRef.current.scrollHeight + "px";
          }
        }, [userInput]);

        useEffect(() => {
          console.log("ðŸš€ Codeer Chat initialized");
        }, []);

        const handleUploadClick = () => {
          if (fileInputRef.current) {
            fileInputRef.current.click();
          }
        };

        const handleFileChange = async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;

          setUploadError("");
          setIsUploading(true);
          try {
            const uploaded = await uploadFile(file);
            setAttachments((prev) => {
              if (prev.some((att) => att.uuid === uploaded.uuid)) return prev;
              return [
                ...prev,
                {
                  uuid: uploaded.uuid,
                  name: uploaded.original_name || file.name,
                  size: uploaded.size || file.size,
                },
              ];
            });
          } catch (error) {
            setUploadError(error.message || "Failed to upload file");
          } finally {
            setIsUploading(false);
            e.target.value = "";
          }
        };

        const removeAttachment = (uuid) => {
          setAttachments((prev) => prev.filter((item) => item.uuid !== uuid));
        };

        const createNewChat = async (name) => {
          if (isCreatingChat) return null;

          setIsCreatingChat(true);
          try {
            const newHistory = await createChat(name.substring(0, 256));
            historyIdRef.current = newHistory.id;
            console.log(`ðŸ†• Chat created with ID: ${newHistory.id}`);
            return newHistory.id;
          } finally {
            setIsCreatingChat(false);
          }
        };

        const sendMessageWithAPI = async (
          message,
          chatHistoryId,
          assistantMessageId,
          attachmentsForSend = []
        ) => {
          setCurrentAssistantMessageId(assistantMessageId);

          setMessages((prev) => [
            ...prev,
            {
              id: assistantMessageId,
              role: "assistant",
              content: "",
            },
          ]);

          try {
            const attachmentIds = attachmentsForSend.map((file) => file.uuid);
            const payload = {
              message: message,
              stream: true,
              agent_id: agentId.current,
            };

            if (attachmentIds.length > 0) {
              payload.attached_file_uuids = attachmentIds;
            }

            let isFirstChunk = true;
            // Clear any previous reasoning steps for this assistant message
            setReasoningStepsByMessage((prev) => {
              const next = { ...prev };
              delete next[assistantMessageId];
              return next;
            });
            await sendQuestion(
              chatHistoryId,
              payload,
              (data) => {
                if (isFirstChunk) {
                  setIsTyping(false);
                  isFirstChunk = false;
                }
                setMessages((prev) =>
                  prev.map((msg) =>
                    msg.id === assistantMessageId
                      ? { ...msg, content: msg.content + data }
                      : msg
                  )
                );
              },
              () => {
                setIsTyping(false);
                setCurrentAssistantMessageId(null);
              },
              (error) => {
                console.error("âŒ API Error:", error);
                setMessages((prev) =>
                  prev.map((msg) =>
                    msg.id === assistantMessageId
                      ? {
                          ...msg,
                          content: `âŒ Error: ${error.message}\n\nPlease check:\n- API key is valid\n- Backend server is running\n- CORS is properly configured`,
                        }
                      : msg
                  )
                );
                setIsTyping(false);
                setCurrentAssistantMessageId(null);
              },
              (event) => {
                if (!event || !event.type || !event.step) return;

                setReasoningStepsByMessage((prev) => {
                  const existing = prev[assistantMessageId] || [];
                  if (event.type === "response.reasoning_step.start") {
                    const step = event.step || {};
                    const id = step.id || `step-${existing.length + 1}`;
                    const newStep = {
                      id,
                      type: step.type || "",
                      content: step.content || "",
                      status: "running",
                      args: step.args || null,
                      result: null,
                    };
                    return {
                      ...prev,
                      [assistantMessageId]: [...existing, newStep],
                    };
                  }

                  if (event.type === "response.reasoning_step.end") {
                    const step = event.step || {};
                    const id = step.id;
                    if (!id || existing.length === 0) {
                      return prev;
                    }
                    const updated = existing.map((s) =>
                      s.id === id
                        ? {
                            ...s,
                            status: "completed",
                            result:
                              (event.step && event.step.result) || s.result,
                            tokenUsage:
                              (event.step && event.step.token_usage) ||
                              s.tokenUsage,
                          }
                        : s
                    );
                    return {
                      ...prev,
                      [assistantMessageId]: updated,
                    };
                  }

                  return prev;
                });
              }
            );
          } catch (error) {
            console.error("Streaming error:", error);
          }
        };

        const sendMessage = async () => {
          const input = userInput.trim();
          if (!input || isTyping || isUploading) return;

          const attachmentsForSend = attachments.map((file) => ({ ...file }));

          // é¢„å…ˆè®¡ç®—ç”¨æˆ·æ¶ˆæ¯å’ŒåŠ©æ‰‹æ¶ˆæ¯çš„ID
          const userMessageId = nextId;
          const assistantMessageId = nextId + 1;
          setNextId(nextId + 2);

          setMessages((prev) => [
            ...prev,
            {
              id: userMessageId,
              role: "user",
              content: input,
              attachments: attachmentsForSend,
            },
          ]);

          setUserInput("");
          setIsTyping(true);

          let currentHistoryId = historyIdRef.current;

          if (!currentHistoryId) {
            try {
              currentHistoryId = await createNewChat(input);
              if (!currentHistoryId) {
                setIsTyping(false);
                return;
              }
            } catch (error) {
              console.error("Failed to create chat:", error);
              setMessages((prev) => [
                ...prev,
                {
                  id: assistantMessageId,
                  role: "assistant",
                  content: `âŒ Error: Failed to create chat session\n\nPlease check:\n- API key is valid\n- Backend server is running\n- CORS is properly configured`,
                },
              ]);
              setIsTyping(false);
              return;
            }
          }

          setAttachments([]);
          setUploadError("");

          await sendMessageWithAPI(
            input,
            currentHistoryId,
            assistantMessageId,
            attachmentsForSend
          );
        };

        const sendExamplePrompt = (prompt) => {
          setUserInput(prompt);
          setTimeout(() => {
            sendMessage();
          }, 0);
        };

        const clearChat = () => {
          historyIdRef.current = null;
          setMessages([]);
          setUserInput("");
          setIsTyping(false);
          setCurrentAssistantMessageId(null);
          setAttachments([]);
          setUploadError("");
          setReasoningStepsByMessage({});
        };

        const handleKeyDown = (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        };

        return (
          <div className="app-container">
            <div className="header">
              <h1>
                <span>ðŸ’¬</span>
                <span>Codeer AI</span>
              </h1>
              <button className="new-chat-btn" onClick={clearChat}>
                + New Chat
              </button>
            </div>

            <div className="messages-container" ref={messagesContainerRef}>
              {messages.length === 0 && (
                <div className="empty-state">
                  <div className="empty-state-icon">ðŸ¤–</div>
                  <h2>How can I help you today?</h2>
                  <div className="example-prompts">
                    <div
                      className="example-prompt"
                      onClick={() =>
                        sendExamplePrompt("Tell me a fun fact about space")
                      }
                    >
                      Tell me a fun fact about space
                    </div>
                    <div
                      className="example-prompt"
                      onClick={() =>
                        sendExamplePrompt("Explain quantum computing")
                      }
                    >
                      Explain quantum computing
                    </div>
                    <div
                      className="example-prompt"
                      onClick={() =>
                        sendExamplePrompt("Give me a recipe for chocolate cake")
                      }
                    >
                      Give me a recipe for chocolate cake
                    </div>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div key={message.id} className={`message ${message.role}`}>
                  <div className="avatar">
                    {message.role === "user" ? "ðŸ‘¤" : "ðŸ¤–"}
                  </div>
                  <div className="message-content">
                    {message.role === "assistant" &&
                    message.content === "" &&
                    isTyping ? (
                      <div className="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                      </div>
                    ) : (
                      <div style={{ whiteSpace: "pre-wrap" }}>
                        {message.role === "assistant"
                          ? renderAssistantContent(message)
                          : message.content}
                      </div>
                    )}
                    {message.attachments && message.attachments.length > 0 && (
                      <div className="message-attachments">
                        {message.attachments.map((file) => (
                          <div className="message-attachment" key={file.uuid}>
                            <span className="message-attachment-icon">ðŸ“Ž</span>
                            <span
                              className="message-attachment-name"
                              title={file.name}
                            >
                              {file.name}
                            </span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>

          <div className="input-area">
              <div className="input-wrapper">
                <input
                  type="file"
                  ref={fileInputRef}
                  style={{ display: "none" }}
                  onChange={handleFileChange}
                />
                <div className="upload-row">
                  <button
                    className="upload-btn"
                    onClick={handleUploadClick}
                    disabled={isUploading}
                  >
                    <span>ðŸ“Ž</span>
                    <span>{isUploading ? "Uploading..." : "Attach file"}</span>
                  </button>
                  <div className="upload-status">
                    {isUploading
                      ? "Uploading to server..."
                      : attachments.length > 0
                      ? `${attachments.length} file${
                          attachments.length > 1 ? "s" : ""
                        } attached`
                      : "Optional: upload files to share with the chat"}
                  </div>
                </div>
                {uploadError && (
                  <div className="upload-error">{uploadError}</div>
                )}
                {attachments.length > 0 && (
                  <div className="attachment-list">
                    {attachments.map((file) => (
                      <div className="attachment-pill" key={file.uuid}>
                        <span className="attachment-name">{file.name}</span>
                        <span className="upload-status">attached</span>
                        <button
                          className="attachment-remove"
                          onClick={() => removeAttachment(file.uuid)}
                          title="Remove attachment"
                        >
                          âœ•
                        </button>
                      </div>
                    ))}
                  </div>
                )}
                <div className="input-container">
                  <textarea
                    ref={textareaRef}
                    value={userInput}
                    onChange={(e) => setUserInput(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder="Send a message..."
                    rows="1"
                  />
                  <button
                    className="send-btn"
                    onClick={sendMessage}
                    disabled={!userInput.trim() || isTyping || isUploading}
                  >
                    <svg viewBox="0 0 24 24">
                      <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Render the app
      const root = ReactDOM.createRoot(document.getElementById("app"));
      root.render(<ChatApp />);
    </script>
  </body>
</html>
